# MapReduce：简化了大集群上的数据处理

## 摘要

> MapReduce 是一种编程模型，一种处理并且产生大量数据集合的相关实现。用户指定一种 *map* 函数， *map* 函数可以对 *key/value* 进行处理， 产生中间状态的  *key/value* ，指定一种 *reduce* 函数， *reduce* 函数可以将所有中间状态的  *key/value*  通过相同的中间状态的 *key* 合并起来。在这篇论文中， 可以发现好多现实世界的任务都可以通过这种模型展现出来。
>
> 这种函数式的程序自动地在一个由大量商业机器组成的大集群上并行运行着。 运行着的系统负责数据的分区， 在这些机器集群上程序执行的调度，机器容错， 管理机器内部通信。这样允许没有任何并行和分布式系统经验的程序员可以方便的使用分布式集群的资源。
>
> 我们 MapReduce 的实现，是运行在一个由大量商业机器上的集群，并且是高度可扩展的：一个典型的MapReduce 在成千上万的机上面处理以 T 为单位计算的数据集合。程序员可以发现这个系统使用非常容易：实现了MapReduce的函数有成百上千个，而且每天有超过1000个MapReduce的任务在Google的集群上运行。

## 1.介绍

在过去的5年中，作者还有许多Google的其他同事为了处理海量的原始数据， 比如爬取的文档，web请求日志等等， 为了计算各种各样的衍生的数据，实现了成百上千个特定的计算程序， 比如倒排索引， 各种各样的网络文档的图数据结构，每个host上面爬取的页面汇总， 指定某天最频繁的请求的集合等等。大部分这些计算程序从概念上看都比较直接。 但是， 数据输入通常比较大，计算任务需要被分配到成百上千台机器上，并且需要在一个合理的时间内完成。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。

为了对付这种复杂度， 我们设计了一个新的抽象， 这种抽象模型只需要我们表述简单的计算，而将并行化处理， 容错， 数据分发，负载均衡封装到一个库里面。设计这种抽象的灵感来自来自 *Lisp* 还有其他函数式编程语言的 *map* 和 *reduce* 源语。我们实现了：对大部分相关的计算，应用一个 *map* 函数计算，将我们输入中的逻辑记录变成 *key/value* 对的集合， 然后应用一个 *reduce* 函数将所有具有相同 *key* 的 values 合理合并。 我们应用的这种指定*map reduce*的函数式编程模型允许我们方便的实现并行化计算， 并且增加重试（re-execution） 作为容灾的主要机制

这项工作的主要贡献是通过简单的接口来实现自动的并行化和大规模计算，并且通过实现了这种接口（map reduce）的程序， 可以实现在海量普通PC上的高性能计算。

第二部分描述基本的编程模型和一些使用案例。第三部分描述了一个经过裁剪的、适合我们的基于集群的计算环境的MapReduce实现。第四部分描述我们认为在MapReduce编程模型中一些实用的技巧。第五部分对于各种不同的任务，测量我们MapReduce实现的性能。第六部分揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。第七部分讨论相关的和未来的工作。

 